以下、Cursorでローカル実行する前提の「指示書（そのままコピペで作れる手順）」を作りました。
狙いはあなたのイメージ通り：

ブラウザに 請求書A/B/C を埋め込み（クリックで表示切替）

自由入力欄に「Aを入力して」など入れる（下の薄いチップでも入力可能）

下の“別システム画面モック”に 1項目ずつ入力が進む（過程が見える）

裏側は LangGraphがイベントをストリーミングして、フロントがアニメ入力する

まずは **OCR/LLMなし（事前抽出JSON）**でデモを最短で成立させます。後でTextract/Bedrockに差し替え可能。

0. 前提（ローカル環境）

Node.js 18+

Python 3.11+

Cursor（ワークスペースを開ければOK）

1. プロジェクト作成（フォルダ構成）

任意の場所で：

mkdir invoice-agent-demo
cd invoice-agent-demo
mkdir backend frontend


最終的な構成：

invoice-agent-demo/
  backend/
    app.py
    requirements.txt
  frontend/
    index.html
    package.json
    vite.config.js
    src/
      main.jsx
      App.jsx
      invoices.js
      styles.css

2. バックエンド（FastAPI + LangGraph SSE）
2.1 backend/requirements.txt

backend/requirements.txt を作成：

fastapi>=0.110
uvicorn[standard]>=0.27
langgraph>=0.2

2.2 backend/app.py

backend/app.py を作成（コピペでOK）：

import json
from typing import TypedDict, Dict, Any, List

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse

from langgraph.graph import StateGraph, START
from langgraph.config import get_stream_writer

# -----------------------------
# デモ用：抽出済み（正規化済み）データ
# -----------------------------
PREBUILT = {
    "A": {
        "vendor_name": "ABC商事",
        "invoice_no": "INV-A-001",
        "invoice_date": "2025-12-01",
        "subtotal": 120000,
        "tax": 12000,
        "total": 132000,
        "pay_due": "2026-01-10",
    },
    "B": {
        "vendor_name": "さくら部品株式会社",
        "invoice_no": "2025/11/30-7788",
        "invoice_date": "2025-11-30",
        "subtotal": 98000,
        "tax": 9800,
        "total": 107800,
        "pay_due": "2026-01-05",
    },
    "C": {
        "vendor_name": "TOYO INDUSTRIES",
        "invoice_no": "C-INV-00042",
        "invoice_date": "2025-10-15",
        "subtotal": 250000,
        "tax": 25000,
        "total": 275000,
        "pay_due": "2025-11-30",
    },
}

TARGET_FIELDS_ORDER = [
    "vendor_name",
    "invoice_no",
    "invoice_date",
    "pay_due",
    "subtotal",
    "tax",
    "total",
]

# -----------------------------
# LangGraph State
# -----------------------------
class State(TypedDict, total=False):
    user_text: str
    doc_id: str
    normalized: Dict[str, Any]
    fill_plan: List[Dict[str, Any]]

def pick_doc(state: State):
    writer = get_stream_writer()
    text = (state.get("user_text") or "").upper()

    # 超単純判定：A/B/C含むか
    doc_id = "A"
    if "B" in text:
        doc_id = "B"
    if "C" in text:
        doc_id = "C"
    if "A" in text:
        doc_id = "A"

    writer({"type": "log", "message": f"対象ドキュメントを決定: {doc_id}"})
    return {"doc_id": doc_id}

def load_or_extract(state: State):
    writer = get_stream_writer()
    doc_id = state["doc_id"]

    writer({"type": "log", "message": f"請求書{doc_id}を読み取り中…（デモ：事前抽出データ使用）"})
    normalized = PREBUILT[doc_id]

    # “作業してる感”のためのダミー工程ログ
    writer({"type": "log", "message": "項目候補を抽出中…"})
    writer({"type": "log", "message": "表記ゆれを正規化中…（請求書番号/日付/金額）"})

    return {"normalized": normalized}

def make_plan(state: State):
    writer = get_stream_writer()
    writer({"type": "log", "message": "別システム項目へのマッピングを作成中…"})

    normalized = state["normalized"]
    plan: List[Dict[str, Any]] = []

    for field in TARGET_FIELDS_ORDER:
        if field in normalized:
            plan.append({"type": "fill", "field": field, "value": normalized[field]})

    writer({"type": "log", "message": f"入力計画を作成（{len(plan)}項目）"})
    return {"fill_plan": plan}

def stream_fill(state: State):
    writer = get_stream_writer()
    writer({"type": "log", "message": "別システムへの入力を開始"})

    for step in state["fill_plan"]:
        # 1項目ずつイベントを吐く（フロントで入力アニメ）
        writer(step)

    writer({"type": "log", "message": "入力完了"})
    return {}

graph = (
    StateGraph(State)
    .add_node("pick_doc", pick_doc)
    .add_node("load_or_extract", load_or_extract)
    .add_node("make_plan", make_plan)
    .add_node("stream_fill", stream_fill)
    .add_edge(START, "pick_doc")
    .add_edge("pick_doc", "load_or_extract")
    .add_edge("load_or_extract", "make_plan")
    .add_edge("make_plan", "stream_fill")
    .compile()
)

app = FastAPI()

# フロントから叩けるようCORS（ローカル向け）
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://127.0.0.1:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/run")
def run(user_text: str):
    def event_stream():
        for chunk in graph.stream({"user_text": user_text}, stream_mode="custom"):
            yield f"data: {json.dumps(chunk, ensure_ascii=False)}\n\n"

    return StreamingResponse(event_stream(), media_type="text/event-stream")

@app.get("/health")
def health():
    return {"ok": True}

2.3 バックエンド起動
cd backend
python -m venv .venv
# mac/linux
source .venv/bin/activate
# windows (powershell)
# .venv\Scripts\Activate.ps1

pip install -r requirements.txt
uvicorn app:app --reload --port 8000


ブラウザで http://127.0.0.1:8000/health が {"ok":true} ならOK。

3. フロントエンド（Vite React：請求書プレビュー + 入力アニメ）
3.1 frontend/package.json

frontend/package.json を作成：

{
  "name": "invoice-agent-demo",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.0",
    "vite": "^5.0.0"
  }
}

3.2 frontend/vite.config.js
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/run": "http://127.0.0.1:8000",
      "/health": "http://127.0.0.1:8000"
    }
  }
});

3.3 frontend/index.html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Invoice Agent Demo</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

3.4 frontend/src/main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./styles.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

3.5 請求書A/B/Cの内容（埋め込み）

frontend/src/invoices.js を作成（※実PDFじゃなくてもデモとして十分“見える”）：

export const invoices = {
  A: `
【請求書 A】
発行元: ABC商事
請求書番号: INV-A-001
発行日: 2025/12/01
支払期日: 2026/01/10

合計金額: 132,000円（税込）
小計: 120,000円
消費税: 12,000円

明細:
- 部品X   10個   10,000円   100,000円
- 送料     1式    20,000円    20,000円
`,
  B: `
【Invoice B】
Supplier: さくら部品株式会社
No.: 2025/11/30-7788
Date: 2025-11-30
Due: 2026-01-05

Total: JPY 107,800
Subtotal: JPY 98,000
Tax(10%): JPY 9,800

Items:
(1) Gasket  20  2,000  40,000
(2) Bolt    50    500  25,000
(3) Handling fee         33,000
`,
  C: `
【INVOICE C】
FROM: TOYO INDUSTRIES
INVOICE#: C-INV-00042
DATE: Oct 15, 2025
PAYMENT DUE: Nov 30, 2025

AMOUNT:
SUBTOTAL 250,000
TAX      25,000
TOTAL   275,000

Details:
A-01 Motor Unit 1  250,000
`
};

3.6 frontend/src/App.jsx

これがメイン。

A/B/Cをクリックでプレビュー切替

チップで「Aを入力」などを入力欄に反映

実行でSSE接続 → ログ表示 → fillイベントで下フォームにタイプ入力

import React, { useMemo, useRef, useState } from "react";
import { invoices } from "./invoices.js";

const FIELD_LABELS = {
  vendor_name: "取引先名",
  invoice_no: "請求書番号",
  invoice_date: "請求日",
  pay_due: "支払期日",
  subtotal: "小計",
  tax: "消費税",
  total: "合計"
};

const FIELD_ORDER = ["vendor_name", "invoice_no", "invoice_date", "pay_due", "subtotal", "tax", "total"];

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

async function typeInto(setter, fullValue, speedMs = 18) {
  const s = String(fullValue);
  let cur = "";
  for (let i = 0; i < s.length; i++) {
    cur += s[i];
    setter(cur);
    await sleep(speedMs);
  }
}

export default function App() {
  const [selected, setSelected] = useState("A");
  const [prompt, setPrompt] = useState("");
  const [logs, setLogs] = useState([]);
  const [running, setRunning] = useState(false);

  const [form, setForm] = useState(() =>
    Object.fromEntries(FIELD_ORDER.map((k) => [k, ""]))
  );
  const [activeField, setActiveField] = useState(null);

  const esRef = useRef(null);

  const chips = useMemo(
    () => [
      { label: "Aを入力", value: "資料Aを入力して" },
      { label: "Bを入力", value: "資料Bを入力して" },
      { label: "Cを入力", value: "資料Cを入力して" }
    ],
    []
  );

  function appendLog(msg) {
    setLogs((prev) => [...prev, { t: new Date().toLocaleTimeString(), msg }]);
  }

  function resetOutput() {
    setLogs([]);
    setForm(Object.fromEntries(FIELD_ORDER.map((k) => [k, ""])));
    setActiveField(null);
  }

  async function handleFill(field, value) {
    setActiveField(field);
    // フィールドを空にしてからタイプする（“入力してる感”）
    setForm((prev) => ({ ...prev, [field]: "" }));
    await sleep(120);
    await typeInto(
      (v) => setForm((prev) => ({ ...prev, [field]: v })),
      value,
      14
    );
    await sleep(120);
  }

  function stop() {
    if (esRef.current) {
      esRef.current.close();
      esRef.current = null;
    }
    setRunning(false);
    setActiveField(null);
    appendLog("停止しました");
  }

  function run() {
    if (!prompt.trim()) return;

    resetOutput();
    setRunning(true);
    appendLog(`指示: ${prompt}`);

    // SSE接続
    const url = `/run?user_text=${encodeURIComponent(prompt)}`;
    const es = new EventSource(url);
    esRef.current = es;

    // キューで順番に処理（fillが一気に来ても順序通りアニメ）
    let queue = Promise.resolve();

    es.onmessage = (ev) => {
      try {
        const data = JSON.parse(ev.data);

        if (data.type === "log") {
          appendLog(data.message);
        } else if (data.type === "fill") {
          appendLog(`入力: ${FIELD_LABELS[data.field] ?? data.field} ← ${data.value}`);
          queue = queue.then(() => handleFill(data.field, data.value));
        }
      } catch (e) {
        appendLog("受信データの解析に失敗しました");
      }
    };

    es.onerror = () => {
      // LangGraphが終わると接続が閉じることがあるので、ここでは“終了扱い”
      es.close();
      esRef.current = null;
      setRunning(false);
      setActiveField(null);
      appendLog("実行終了（接続クローズ）");
    };
  }

  return (
    <div className="page">
      <header className="header">
        <div>
          <div className="title">請求書AIエージェント（デモ）</div>
          <div className="sub">A/B/Cの表記ゆれを吸収して、別システムへ1項目ずつ入力する “作業してる感” デモ</div>
        </div>
      </header>

      <div className="grid">
        {/* 左：請求書 */}
        <section className="card">
          <div className="cardTitle">請求書プレビュー</div>
          <div className="tabs">
            {["A", "B", "C"].map((k) => (
              <button
                key={k}
                className={`tab ${selected === k ? "active" : ""}`}
                onClick={() => setSelected(k)}
              >
                {k}
              </button>
            ))}
          </div>
          <pre className="invoice">{invoices[selected]}</pre>
        </section>

        {/* 中：指示＋ログ */}
        <section className="card">
          <div className="cardTitle">指示</div>
          <textarea
            className="prompt"
            placeholder="例：資料Aを入力して"
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            disabled={running}
          />
          <div className="chips">
            {chips.map((c) => (
              <button
                key={c.label}
                className="chip"
                onClick={() => setPrompt(c.value)}
                disabled={running}
                title="クリックで入力欄に反映"
              >
                {c.label}
              </button>
            ))}
          </div>

          <div className="actions">
            <button className="btn" onClick={run} disabled={running || !prompt.trim()}>
              実行
            </button>
            <button className="btn ghost" onClick={stop} disabled={!running}>
              停止
            </button>
          </div>

          <div className="cardTitle" style={{ marginTop: 12 }}>実行ログ</div>
          <div className="log">
            {logs.length === 0 ? (
              <div className="logEmpty">ここに進捗が流れます（OCR→正規化→入力…）</div>
            ) : (
              logs.map((l, i) => (
                <div key={i} className="logLine">
                  <span className="logTime">{l.t}</span>
                  <span>{l.msg}</span>
                </div>
              ))
            )}
          </div>
        </section>

        {/* 右：別システム画面モック */}
        <section className="card">
          <div className="cardTitle">別システム画面（モック）</div>
          <div className="form">
            {FIELD_ORDER.map((k) => (
              <div key={k} className={`row ${activeField === k ? "activeRow" : ""}`}>
                <div className="label">{FIELD_LABELS[k] ?? k}</div>
                <input className="input" value={form[k]} readOnly />
              </div>
            ))}
          </div>
          <div className="hint">
            ※このフォームへの入力は、LangGraphが送る <code>fill</code> イベントを受けて1項目ずつアニメしています。
          </div>
        </section>
      </div>
    </div>
  );
}

3.7 frontend/src/styles.css
:root {
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
  color: #111827;
  background: #f6f7fb;
}

.page { padding: 18px; }
.header { margin-bottom: 14px; }
.title { font-size: 18px; font-weight: 700; }
.sub { margin-top: 4px; font-size: 12px; color: #6b7280; }

.grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 14px;
  align-items: start;
}

.card {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 14px;
  box-shadow: 0 1px 8px rgba(0,0,0,0.04);
  padding: 14px;
}

.cardTitle { font-weight: 700; font-size: 13px; margin-bottom: 10px; }

.tabs { display: flex; gap: 8px; margin-bottom: 10px; }
.tab {
  border: 1px solid #e5e7eb;
  background: #f9fafb;
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
}
.tab.active { border-color: #111827; }

.invoice {
  background: #0b1220;
  color: #e5e7eb;
  padding: 12px;
  border-radius: 10px;
  height: 520px;
  overflow: auto;
  white-space: pre-wrap;
}

.prompt {
  width: 100%;
  height: 86px;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 10px;
  resize: none;
}

.chips { display: flex; gap: 8px; margin-top: 10px; }
.chip {
  border: 1px dashed #d1d5db;
  background: #f9fafb;
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 12px;
  cursor: pointer;
  color: #374151;
  opacity: 0.85;
}
.chip:disabled { opacity: 0.5; cursor: not-allowed; }

.actions { display: flex; gap: 10px; margin-top: 10px; }
.btn {
  border: 1px solid #111827;
  background: #111827;
  color: white;
  border-radius: 12px;
  padding: 8px 12px;
  cursor: pointer;
}
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.btn.ghost {
  background: white;
  color: #111827;
}

.log {
  margin-top: 8px;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  background: #fcfcfd;
  height: 280px;
  overflow: auto;
  padding: 10px;
  font-size: 12px;
}
.logEmpty { color: #9ca3af; }
.logLine { display: flex; gap: 10px; padding: 3px 0; }
.logTime { color: #9ca3af; min-width: 84px; }

.form { display: grid; gap: 10px; }
.row {
  display: grid;
  grid-template-columns: 110px 1fr;
  gap: 10px;
  align-items: center;
  padding: 8px;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
}
.row.activeRow {
  border-color: #111827;
  box-shadow: 0 0 0 3px rgba(17,24,39,0.08);
}
.label { font-size: 12px; color: #374151; }
.input {
  width: 100%;
  border: 1px solid #e5e7eb;
  border-radius: 10px;
  padding: 8px 10px;
  background: #f9fafb;
}

.hint { margin-top: 10px; font-size: 12px; color: #6b7280; }
code { background: #f3f4f6; padding: 2px 6px; border-radius: 8px; }

3.8 フロント起動

別ターミナルで：

cd frontend
npm install
npm run dev


ブラウザで http://localhost:5173 を開く。

4. デモ手順（見せ方）

左の請求書タブで A/B/C を切替（表現/順番が違うのを見せる）

指示欄に「資料Aを入力して」

もしくは薄いチップ「Aを入力」をクリック

実行

中央にログが流れ、右のフォームに 1項目ずつ入力されるのを見せる